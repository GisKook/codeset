!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
BINDPORT	CNConfig.h	18;"	d
BeginTransaction	PGDatabase.cpp	/^bool PGDatabase::BeginTransaction() {$/;"	f	class:PGDatabase
CNCONFIG_H_H	CNConfig.h	9;"	d
CNConfig	CNConfig.h	/^	CNConfig(){};$/;"	f	class:CNConfig
CNConfig	CNConfig.h	/^	CNConfig(const CNConfig&){};$/;"	f	class:CNConfig
CNConfig	CNConfig.h	/^class CNConfig{$/;"	c
CNDEF_H_H	cndef.h	9;"	d
CNTOOLKIT_H_H	toolkit.h	9;"	d
CODESET_CNCONFIG_H_H	cnconfig.h	2;"	d
CODESET_CNCOSOLE_H_H	cnconsole.h	2;"	d
CODESET_FMTREPORTSOCKDATA_H_H	fmtreportsockdata.h	2;"	d
CODESET_PARSEPROTOCOL_H_H	parseprotocol.h	2;"	d
CODESET_PROCESSAPPDATA_H_H	processappdata.h	2;"	d
CODESET_SOCKETS_BUFFER_H_H	sockets_buffer.h	2;"	d
Commit	PGDatabase.cpp	/^bool PGDatabase::Commit() {$/;"	f	class:PGDatabase
Connect	PGDatabase.cpp	/^int PGDatabase::Connect( const PGConnInfo& dbConnInfo ) {$/;"	f	class:PGDatabase
DBHOST	CNConfig.h	19;"	d
DBHOST	cnconfig.h	5;"	d
DBNAME	CNConfig.h	21;"	d
DBNAME	cnconfig.h	7;"	d
DBPORT	CNConfig.h	20;"	d
DBPORT	cnconfig.h	6;"	d
DBPWD	CNConfig.h	23;"	d
DBPWD	cnconfig.h	9;"	d
DBUSER	CNConfig.h	22;"	d
DBUSER	cnconfig.h	8;"	d
DisConnect	PGDatabase.cpp	/^int PGDatabase::DisConnect() {$/;"	f	class:PGDatabase
ENDIANNESS	cndef.h	23;"	d
Exec	PGDatabase.cpp	/^bool PGDatabase::Exec( const char* strSQL ) {$/;"	f	class:PGDatabase
FORWARDPORT	CNConfig.h	24;"	d
GKDATABASEPG_H_H	PGDatabase.h	9;"	d
GetInstance	CNConfig.cpp	/^CNConfig& CNConfig::GetInstance()$/;"	f	class:CNConfig
GetValue	CNConfig.cpp	/^const char* CNConfig::GetValue( const char* key)$/;"	f	class:CNConfig
INIT_LIST_HEAD	list.h	/^static inline void INIT_LIST_HEAD(struct list_head *list)$/;"	f
ISBIGENDIAN	cndef.h	24;"	d
LIST_HEAD	list.h	19;"	d
LIST_HEAD_INIT	list.h	17;"	d
LoadFile	CNConfig.cpp	/^bool CNConfig::LoadFile( const char* filename)$/;"	f	class:CNConfig
MAXFIFOLEN	sockets_buffer.c	9;"	d	file:
MAX_ACCEPTSOCKETS	main.c	15;"	d	file:
MAX_EVENT	main.c	14;"	d	file:
MAX_FIFO_LEN	processappdata.c	15;"	d	file:
MAX_RECVLEN	main.c	16;"	d	file:
MAX_REQUEST_LEN	parseprotocol.c	10;"	d	file:
PCM	cnconsole.h	7;"	d
PEERIP	CNConfig.h	16;"	d
PEERPORT	CNConfig.h	17;"	d
PGConnInfo	PGDatabase.h	/^}PGConnInfo;$/;"	t	typeref:struct:__anon1
PGDatabase	PGDatabase.h	/^class PGDatabase{$/;"	c
PGconn	PGDatabase.h	/^typedef struct pg_conn PGconn;$/;"	t	typeref:struct:pg_conn
PRM	cnconsole.h	6;"	d
QUIT	cnconsole.h	5;"	d
Query	PGDatabase.cpp	/^PGRecordset* PGDatabase::Query( const char* strSQL ) {$/;"	f	class:PGDatabase
REQ_HEARTBEAT	parseprotocol.h	7;"	d
REQ_LOGIN	parseprotocol.h	5;"	d
REQ_LOGOFF	parseprotocol.h	6;"	d
REQ_REQ	parseprotocol.h	8;"	d
REQ_UNKNOWN	parseprotocol.h	4;"	d
SRC	makefile	/^SRC = main.c cnconsole.c sockets_buffer.c kfifo.c toolkit.c processappdata.c parseprotocol.c fmtreportsockdata.c$/;"	m
STOREDBFREQUENCY	CNConfig.h	25;"	d
STOREDBINTERVEL	CNConfig.h	26;"	d
TARGET	makefile	/^TARGET = test$/;"	m
TMPSIZE	fmtreportsockdata.c	19;"	d	file:
TOOLKIT_BYTE2INT	toolkit.h	19;"	d
TOOLKIT_BYTE2SHORT	toolkit.h	20;"	d
_LINUX_KFIFO_H	kfifo.h	22;"	d
_LIST_HEAD_	list.h	2;"	d
__list_add	list.h	/^static inline void __list_add(struct list_head *new_item,$/;"	f
__list_cut_position	list.h	/^static inline void __list_cut_position(struct list_head *list,$/;"	f
__list_del	list.h	/^static inline void __list_del(struct list_head * prev, struct list_head * next)$/;"	f
__list_splice	list.h	/^static inline void __list_splice(const struct list_head *list,$/;"	f
account	encodeprotocol.c	/^	char account[12];$/;"	m	struct:respondheartbeat	file:
account	encodeprotocol.c	/^	char account[12];$/;"	m	struct:respondlogin	file:
account	parseprotocol.h	/^	char account[12];$/;"	m	struct:heartbeat
account	parseprotocol.h	/^	char account[12];$/;"	m	struct:login
account	parseprotocol.h	/^	char account[12];$/;"	m	struct:logoff
accuracy	encodeprotocol.c	/^	unsigned char accuracy;$/;"	m	struct:positioninfo	file:
announcementcall	parseprotocol.h	/^	unsigned char announcementcall;$/;"	m	struct:request
buffer	kfifo.h	/^	unsigned char *buffer;	\/* the buffer holding the data *\/$/;"	m	struct:kfifo
byteliterals	toolkit.c	/^const char* byteliterals[] = {"00","01","02","03","04","05","06","07","08","09","0A","0B","0C","0D","0E","0F","10","11","12","13","14","15","16","17","18","19","1A","1B","1C","1D","1E","1F","20","21","22","23","24","25","26","27","28","29","2A","2B","2C","2D","2E","2F","30","31","32","33","34","35","36","37","38","39","3A","3B","3C","3D","3E","3F","40","41","42","43","44","45","46","47","48","49","4A","4B","4C","4D","4E","4F","50","51","52","53","54","55","56","57","58","59","5A","5B","5C","5D","5E","5F","60","61","62","63","64","65","66","67","68","69","6A","6B","6C","6D","6E","6F","70","71","72","73","74","75","76","77","78","79","7A","7B","7C","7D","7E","7F","80","81","82","83","84","85","86","87","88","89","8A","8B","8C","8D","8E","8F","90","91","92","93","94","95","96","97","98","99","9A","9B","9C","9D","9E","9F","A0","A1","A2","A3","A4","A5","A6","A7","A8","A9","AA","AB","AC","AD","AE","AF","B0","B1","B2","B3","B4","B5","B6","B7","B8","B9","BA","BB","BC","BD","BE","BF","C0","C1","C2","C3","C4","C5","C6","C7","C8","C9","CA","CB","CC","CD","CE","CF","D0","D1","D2","D3","D4","D5","D6","D7","D8","D9","DA","DB","DC","DD","DE","DF","E0","E1","E2","E3","E4","E5","E6","E7","E8","E9","EA","EB","EC","ED","EE","EF","F0","F1","F2","F3","F4","F5","F6","F7","F8","F9","FA","FB","FC","FD","FE","FF"};$/;"	v
c	cndef.h	/^	char c[4];$/;"	m	union:__anon2
cJSON	cJSON.h	/^typedef struct cJSON {$/;"	s
cJSON	cJSON.h	/^} cJSON;$/;"	t	typeref:struct:cJSON
cJSON_AddBoolToObject	cJSON.h	132;"	d
cJSON_AddFalseToObject	cJSON.h	131;"	d
cJSON_AddItemReferenceToArray	cJSON.c	/^void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}$/;"	f
cJSON_AddItemReferenceToObject	cJSON.c	/^void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}$/;"	f
cJSON_AddItemToArray	cJSON.c	/^void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}$/;"	f
cJSON_AddItemToObject	cJSON.c	/^void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}$/;"	f
cJSON_AddNullToObject	cJSON.h	129;"	d
cJSON_AddNumberToObject	cJSON.h	133;"	d
cJSON_AddStringToObject	cJSON.h	134;"	d
cJSON_AddTrueToObject	cJSON.h	130;"	d
cJSON_Array	cJSON.h	37;"	d
cJSON_CreateArray	cJSON.c	/^cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}$/;"	f
cJSON_CreateBool	cJSON.c	/^cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}$/;"	f
cJSON_CreateDoubleArray	cJSON.c	/^cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateFalse	cJSON.c	/^cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}$/;"	f
cJSON_CreateFloatArray	cJSON.c	/^cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateIntArray	cJSON.c	/^cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateNull	cJSON.c	/^cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}$/;"	f
cJSON_CreateNumber	cJSON.c	/^cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}$/;"	f
cJSON_CreateObject	cJSON.c	/^cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}$/;"	f
cJSON_CreateString	cJSON.c	/^cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}$/;"	f
cJSON_CreateStringArray	cJSON.c	/^cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateTrue	cJSON.c	/^cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}$/;"	f
cJSON_Delete	cJSON.c	/^void cJSON_Delete(cJSON *c)$/;"	f
cJSON_DeleteItemFromArray	cJSON.c	/^void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}$/;"	f
cJSON_DeleteItemFromObject	cJSON.c	/^void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}$/;"	f
cJSON_DetachItemFromArray	cJSON.c	/^cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)			{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;$/;"	f
cJSON_DetachItemFromObject	cJSON.c	/^cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}$/;"	f
cJSON_Duplicate	cJSON.c	/^cJSON *cJSON_Duplicate(cJSON *item,int recurse)$/;"	f
cJSON_False	cJSON.h	32;"	d
cJSON_GetArrayItem	cJSON.c	/^cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}$/;"	f
cJSON_GetArraySize	cJSON.c	/^int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}$/;"	f
cJSON_GetErrorPtr	cJSON.c	/^const char *cJSON_GetErrorPtr(void) {return ep;}$/;"	f
cJSON_GetObjectItem	cJSON.c	/^cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}$/;"	f
cJSON_Hooks	cJSON.h	/^typedef struct cJSON_Hooks {$/;"	s
cJSON_Hooks	cJSON.h	/^} cJSON_Hooks;$/;"	t	typeref:struct:cJSON_Hooks
cJSON_InitHooks	cJSON.c	/^void cJSON_InitHooks(cJSON_Hooks* hooks)$/;"	f
cJSON_IsReference	cJSON.h	40;"	d
cJSON_Minify	cJSON.c	/^void cJSON_Minify(char *json)$/;"	f
cJSON_NULL	cJSON.h	34;"	d
cJSON_New_Item	cJSON.c	/^static cJSON *cJSON_New_Item(void)$/;"	f	file:
cJSON_Number	cJSON.h	35;"	d
cJSON_Object	cJSON.h	38;"	d
cJSON_Parse	cJSON.c	/^cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}$/;"	f
cJSON_ParseWithOpts	cJSON.c	/^cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)$/;"	f
cJSON_Print	cJSON.c	/^char *cJSON_Print(cJSON *item)				{return print_value(item,0,1);}$/;"	f
cJSON_PrintUnformatted	cJSON.c	/^char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0);}$/;"	f
cJSON_ReplaceItemInArray	cJSON.c	/^void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;$/;"	f
cJSON_ReplaceItemInObject	cJSON.c	/^void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}$/;"	f
cJSON_SetIntValue	cJSON.h	137;"	d
cJSON_String	cJSON.h	36;"	d
cJSON_True	cJSON.h	33;"	d
cJSON__h	cJSON.h	24;"	d
cJSON_free	cJSON.c	/^static void (*cJSON_free)(void *ptr) = free;$/;"	v	file:
cJSON_malloc	cJSON.c	/^static void *(*cJSON_malloc)(size_t sz) = malloc;$/;"	v	file:
cJSON_strcasecmp	cJSON.c	/^static int cJSON_strcasecmp(const char *s1,const char *s2)$/;"	f	file:
cJSON_strdup	cJSON.c	/^static char* cJSON_strdup(const char* str)$/;"	f	file:
checksum	parseprotocol.c	/^unsigned char checksum(unsigned char * buf, unsigned int len){ $/;"	f
child	cJSON.h	/^	struct cJSON *child;		\/* An array or object item will have a child pointer pointing to a chain of the items in the array\/object. *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON
cnconfig_getvalue	cnconfig.c	/^char* cnconfig_getvalue( const char * key ){$/;"	f
cnconfig_loadfile	cnconfig.c	/^int cnconfig_loadfile( const char* filename ){ $/;"	f
cnconfig_map	cnconfig.c	/^map<string, string>cnconfig_map;$/;"	v
cnconfig_setconfig	cnconfig.c	/^int cnconfig_setconfig(cJSON* json, const char * configkey, const char * errormsg){$/;"	f
communicationinfo	encodeprotocol.c	/^		struct communicationinfo* communicationinfo;$/;"	m	union:encodeprotocol_respond::__anon3	typeref:struct:encodeprotocol_respond::__anon3::communicationinfo	file:
communicationinfo	encodeprotocol.c	/^struct communicationinfo{$/;"	s	file:
communicationreceipt	encodeprotocol.c	/^		struct communicationreceipt* communicationreceipt;$/;"	m	union:encodeprotocol_respond::__anon3	typeref:struct:encodeprotocol_respond::__anon3::communicationreceipt	file:
communicationreceipt	encodeprotocol.c	/^struct communicationreceipt{$/;"	s	file:
console_parsecmd	cnconsole.c	/^int console_parsecmd(unsigned char* buf, struct sockets_buffer* socketbuf){ $/;"	f
console_print_cmds	cnconsole.c	/^int console_print_cmds(){ $/;"	f
container_of	list.h	35;"	d
create_reference	cJSON.c	/^static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}$/;"	f	file:
dbName	PGDatabase.h	/^	char* dbName;$/;"	m	struct:__anon1
debug_printbytes	toolkit.c	/^void debug_printbytes(unsigned char* buf, unsigned int len){$/;"	f
detlaelevation	encodeprotocol.c	/^	short detlaelevation;$/;"	m	struct:positioninfo	file:
encodelogin	encodeprotocol.c	/^int encodelogin(struct respondlogin* respondlogin, unsigned char * buf, int& len){$/;"	f
encodeprotocol_respond	encodeprotocol.c	/^struct encodeprotocol_respond{$/;"	s	file:
encodingtype	encodeprotocol.c	/^	unsigned char encodingtype;$/;"	m	struct:communicationinfo	file:
encodingtype	parseprotocol.h	/^	unsigned char encodingtype;$/;"	m	struct:request
endian_test	cndef.h	/^}endian_test={{'l','?','?','b'}};$/;"	v	typeref:union:__anon2
ep	cJSON.c	/^static const char *ep;$/;"	v	file:
fd	fmtreportsockdata.c	/^	int fd;$/;"	m	struct:fmtreportsockdata	file:
fd	sockets_buffer.c	/^	int fd;$/;"	m	struct:fd_buffer	file:
fd_buffer	sockets_buffer.c	/^struct fd_buffer{$/;"	s	file:
fd_sigfmt	processappdata.c	/^	int fd_sigfmt;$/;"	m	struct:processappdata	file:
fifo	sockets_buffer.c	/^	struct kfifo* fifo;	$/;"	m	struct:fd_buffer	typeref:struct:fd_buffer::kfifo	file:
firstByteMark	cJSON.c	/^static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };$/;"	v	file:
fmtmsg	processappdata.c	/^void * fmtmsg(void * p){$/;"	f
fmtreportsockdata	fmtreportsockdata.c	/^struct fmtreportsockdata{$/;"	s	file:
fmtreportsockdata_add	fmtreportsockdata.c	/^int fmtreportsockdata_add(struct list_head * head, struct kfifo* fifo){ $/;"	f
fmtreportsockdata_clear	fmtreportsockdata.c	/^int fmtreportsockdata_clear(struct fmtreportsockdata* msg ){ $/;"	f
forwardmsg	processappdata.c	/^void * forwardmsg(void * param){ $/;"	f
free_fn	cJSON.h	/^      void (*free_fn)(void *ptr);$/;"	m	struct:cJSON_Hooks
geodeticheight	encodeprotocol.c	/^	short geodeticheight;$/;"	m	struct:positioninfo	file:
getrequesttype	parseprotocol.c	/^int getrequesttype(unsigned char* buf){ $/;"	f
head	processappdata.c	/^	struct list_head head;$/;"	m	struct:processappdata	typeref:struct:processappdata::list_head	file:
heartbeat	parseprotocol.h	/^		struct heartbeat* heartbeat;$/;"	m	union:parseprotocol_request::__anon4	typeref:struct:parseprotocol_request::__anon4::heartbeat
heartbeat	parseprotocol.h	/^struct heartbeat{$/;"	s
hex2char	toolkit.c	/^void hex2char(char* charbuf, unsigned char* hexbuf, unsigned int len){$/;"	f
hour	encodeprotocol.c	/^	unsigned char hour;$/;"	m	struct:time	file:
id	encodeprotocol.c	/^	unsigned int id;$/;"	m	struct:positioninfo	file:
in	kfifo.h	/^	unsigned int in;	\/* data is added at offset (in % size) *\/$/;"	m	struct:kfifo
ip	sockets_buffer.c	/^	char ip[16];$/;"	m	struct:fd_buffer	file:
kfifo	kfifo.h	/^struct kfifo {$/;"	s
kfifo_free	kfifo.c	/^void kfifo_free(struct kfifo *fifo)$/;"	f
kfifo_get	kfifo.c	/^unsigned int kfifo_get(struct kfifo *fifo,$/;"	f
kfifo_init	kfifo.c	/^struct kfifo *kfifo_init( unsigned int size)$/;"	f
kfifo_len	kfifo.h	/^static inline unsigned int kfifo_len(struct kfifo *fifo)$/;"	f
kfifo_put	kfifo.c	/^unsigned int kfifo_put(struct kfifo *fifo,$/;"	f
kfifo_reset	kfifo.h	/^static inline void kfifo_reset(struct kfifo *fifo)$/;"	f
l	cndef.h	/^	unsigned long l;$/;"	m	union:__anon2
latitude	encodeprotocol.c	/^	unsigned int latitude;$/;"	m	struct:positioninfo	file:
likely	cndef.h	12;"	d
likely	cndef.h	15;"	d
list	fmtreportsockdata.c	/^	struct list_head list;$/;"	m	struct:fmtreportsockdata	typeref:struct:fmtreportsockdata::list_head	file:
list_add	list.h	/^static inline void list_add(struct list_head *new_item, struct list_head *head)$/;"	f
list_add_tail	list.h	/^static inline void list_add_tail(struct list_head *new_item, struct list_head *head)$/;"	f
list_cut_position	list.h	/^static inline void list_cut_position(struct list_head *list,$/;"	f
list_del	list.h	/^static inline void list_del(struct list_head *entry)$/;"	f
list_del_init	list.h	/^static inline void list_del_init(struct list_head *entry)$/;"	f
list_empty	list.h	/^static inline int list_empty(const struct list_head *head)$/;"	f
list_empty_careful	list.h	/^static inline int list_empty_careful(const struct list_head *head)$/;"	f
list_entry	list.h	343;"	d
list_first_entry	list.h	354;"	d
list_for_each_safe	list.h	31;"	d
list_head	list.h	/^struct list_head {$/;"	s
list_is_last	list.h	/^static inline int list_is_last(const struct list_head *list,$/;"	f
list_is_singular	list.h	/^static inline int list_is_singular(const struct list_head *head)$/;"	f
list_move	list.h	/^static inline void list_move(struct list_head *list, struct list_head *head)$/;"	f
list_move_tail	list.h	/^static inline void list_move_tail(struct list_head *list,$/;"	f
list_replace	list.h	/^static inline void list_replace(struct list_head *old,$/;"	f
list_replace_init	list.h	/^static inline void list_replace_init(struct list_head *old,$/;"	f
list_splice	list.h	/^static inline void list_splice(const struct list_head *list,$/;"	f
list_splice_init	list.h	/^static inline void list_splice_init(struct list_head *list,$/;"	f
list_splice_tail	list.h	/^static inline void list_splice_tail(struct list_head *list,$/;"	f
list_splice_tail_init	list.h	/^static inline void list_splice_tail_init(struct list_head *list,$/;"	f
login	PGDatabase.h	/^	char* login;$/;"	m	struct:__anon1
login	parseprotocol.h	/^		struct login* login;$/;"	m	union:parseprotocol_request::__anon4	typeref:struct:parseprotocol_request::__anon4::login
login	parseprotocol.h	/^struct login{$/;"	s
loginresult	encodeprotocol.c	/^	unsigned char loginresult;$/;"	m	struct:respondlogin	file:
logoff	parseprotocol.h	/^		struct logoff* logoff;$/;"	m	union:parseprotocol_request::__anon4	typeref:struct:parseprotocol_request::__anon4::logoff
logoff	parseprotocol.h	/^struct logoff{ $/;"	s
longitude	encodeprotocol.c	/^	unsigned int longitude;$/;"	m	struct:positioninfo	file:
m_mapConfig	CNConfig.h	/^	std::map<std::string, std::string> m_mapConfig;$/;"	m	class:CNConfig
m_pConnect	PGDatabase.h	/^	PGconn* m_pConnect;$/;"	m	class:PGDatabase
main	main.c	/^int main(){ $/;"	f
main	test.c	/^int main(){$/;"	f
malloc_fn	cJSON.h	/^      void *(*malloc_fn)(size_t sz);$/;"	m	struct:cJSON_Hooks
message	encodeprotocol.c	/^	unsigned char message[210]; $/;"	m	struct:communicationinfo	file:
message	encodeprotocol.c	/^	}message;$/;"	m	struct:encodeprotocol_respond	typeref:union:encodeprotocol_respond::__anon3	file:
message	fmtreportsockdata.c	/^	struct parseprotocol_request * message;$/;"	m	struct:fmtreportsockdata	typeref:struct:fmtreportsockdata::parseprotocol_request	file:
message	parseprotocol.h	/^	unsigned char message[210];$/;"	m	struct:request
message	parseprotocol.h	/^	}message;$/;"	m	struct:parseprotocol_request	typeref:union:parseprotocol_request::__anon4
messagelength	parseprotocol.h	/^	unsigned short messagelength;$/;"	m	struct:request
messagetype	encodeprotocol.c	/^	unsigned char messagetype;$/;"	m	struct:encodeprotocol_respond	file:
messagetype	parseprotocol.h	/^	unsigned char messagetype;$/;"	m	struct:parseprotocol_request
min	kfifo.c	24;"	d	file:
minutes	encodeprotocol.c	/^	unsigned char minutes;$/;"	m	struct:time	file:
multivaluesolution	encodeprotocol.c	/^	unsigned char multivaluesolution;$/;"	m	struct:positioninfo	file:
next	cJSON.h	/^	struct cJSON *next,*prev;	\/* next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON
next	list.h	/^	struct list_head *next, *prev;$/;"	m	struct:list_head	typeref:struct:list_head::list_head
next	sockets_buffer.c	/^	struct fd_buffer* next;$/;"	m	struct:fd_buffer	typeref:struct:fd_buffer::fd_buffer	file:
off_setof	list.h	28;"	d
operationdb	processappdata.c	/^void * operationdb(void * param){ $/;"	f
out	kfifo.h	/^	unsigned int out;	\/* data is extracted from off. (out % size) *\/$/;"	m	struct:kfifo
parse_array	cJSON.c	/^static const char *parse_array(cJSON *item,const char *value)$/;"	f	file:
parse_hex4	cJSON.c	/^static unsigned parse_hex4(const char *str)$/;"	f	file:
parse_number	cJSON.c	/^static const char *parse_number(cJSON *item,const char *num)$/;"	f	file:
parse_object	cJSON.c	/^static const char *parse_object(cJSON *item,const char *value)$/;"	f	file:
parse_string	cJSON.c	/^static const char *parse_string(cJSON *item,const char *str)$/;"	f	file:
parse_value	cJSON.c	/^static const char *parse_value(cJSON *item,const char *value)$/;"	f	file:
parseheartbeat	parseprotocol.c	/^int parseheartbeat(struct heartbeat* heartbeat, unsigned char * buf){$/;"	f
parselogin	parseprotocol.c	/^int parselogin(struct login* login, unsigned char * buf){$/;"	f
parselogoff	parseprotocol.c	/^int parselogoff(struct logoff* logoff, unsigned char * buf){$/;"	f
parseprotocol_clear	parseprotocol.c	/^int parseprotocol_clear(struct parseprotocol_request* ppr){$/;"	f
parseprotocol_parserequest	parseprotocol.c	/^int parseprotocol_parserequest(struct parseprotocol_request* ppr,unsigned char * buf, unsigned int len){$/;"	f
parseprotocol_request	parseprotocol.h	/^struct parseprotocol_request{$/;"	s
parserequest	parseprotocol.c	/^int parserequest(struct request* request, unsigned char * buf){$/;"	f
passwd	PGDatabase.h	/^	char* passwd; $/;"	m	struct:__anon1
password	parseprotocol.h	/^	char password[8];$/;"	m	struct:login
pghost	PGDatabase.h	/^	char* pghost;$/;"	m	struct:__anon1
pgport	PGDatabase.h	/^	char* pgport;$/;"	m	struct:__anon1
positioninfo	encodeprotocol.c	/^struct positioninfo{ $/;"	s	file:
positiontime	encodeprotocol.c	/^	struct time positiontime;$/;"	m	struct:positioninfo	typeref:struct:positioninfo::time	file:
postioninfo	encodeprotocol.c	/^		struct positioninfo* postioninfo;$/;"	m	union:encodeprotocol_respond::__anon3	typeref:struct:encodeprotocol_respond::__anon3::positioninfo	file:
prev	cJSON.h	/^	struct cJSON *next,*prev;	\/* next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::
prev	list.h	/^	struct list_head *next, *prev;$/;"	m	struct:list_head	typeref:struct:list_head::
print_array	cJSON.c	/^static char *print_array(cJSON *item,int depth,int fmt)$/;"	f	file:
print_number	cJSON.c	/^static char *print_number(cJSON *item)$/;"	f	file:
print_object	cJSON.c	/^static char *print_object(cJSON *item,int depth,int fmt)$/;"	f	file:
print_string	cJSON.c	/^static char *print_string(cJSON *item)	{return print_string_ptr(item->valuestring);}$/;"	f	file:
print_string_ptr	cJSON.c	/^static char *print_string_ptr(const char *str)$/;"	f	file:
print_value	cJSON.c	/^static char *print_value(cJSON *item,int depth,int fmt)$/;"	f	file:
processappdata	processappdata.c	/^struct processappdata{$/;"	s	file:
processappdata_create	processappdata.c	/^struct processappdata * processappdata_create(struct sockets_buffer * sbuf, int fd_sigfmt){$/;"	f
processappdata_exit	processappdata.c	/^int processappdata_exit(struct processappdata* pad, pthread_t tid_db, pthread_t tid_upward){$/;"	f
processappdata_join	processappdata.c	/^int processappdata_join(struct processappdata* pad){$/;"	f
processed	fmtreportsockdata.c	/^	unsigned char processed;$/;"	m	struct:fmtreportsockdata	file:
receipttime	encodeprotocol.c	/^	struct time receipttime;$/;"	m	struct:communicationreceipt	typeref:struct:communicationreceipt::time	file:
recvaddr	encodeprotocol.c	/^	unsigned int recvaddr;$/;"	m	struct:communicationinfo	file:
recvaddr	encodeprotocol.c	/^	unsigned int recvaddr;$/;"	m	struct:communicationreceipt	file:
recvaddr	parseprotocol.h	/^	int recvaddr;$/;"	m	struct:request
repeater_create	repeater.c	/^int repeater_create(){$/;"	f
request	parseprotocol.h	/^		struct request* request;$/;"	m	union:parseprotocol_request::__anon4	typeref:struct:parseprotocol_request::__anon4::request
request	parseprotocol.h	/^struct request{ $/;"	s
requestid	parseprotocol.h	/^	unsigned int requestid;$/;"	m	struct:request
respondheartbeat	encodeprotocol.c	/^		struct respondheartbeat* respondheartbeat;$/;"	m	union:encodeprotocol_respond::__anon3	typeref:struct:encodeprotocol_respond::__anon3::respondheartbeat	file:
respondheartbeat	encodeprotocol.c	/^struct respondheartbeat{$/;"	s	file:
respondlogin	encodeprotocol.c	/^		struct respondlogin* respondlogin;$/;"	m	union:encodeprotocol_respond::__anon3	typeref:struct:encodeprotocol_respond::__anon3::respondlogin	file:
respondlogin	encodeprotocol.c	/^struct respondlogin{$/;"	s	file:
sbuf	processappdata.c	/^	struct sockets_buffer* sbuf;$/;"	m	struct:processappdata	typeref:struct:processappdata::sockets_buffer	file:
seconds	encodeprotocol.c	/^	unsigned char seconds;$/;"	m	struct:time	file:
sendaddr	encodeprotocol.c	/^	unsigned int sendaddr;$/;"	m	struct:communicationinfo	file:
sendaddr	encodeprotocol.c	/^	unsigned int sendaddr;$/;"	m	struct:communicationreceipt	file:
sendaddr	parseprotocol.h	/^	int sendaddr;$/;"	m	struct:request
sendtime	encodeprotocol.c	/^	struct time sendtime;$/;"	m	struct:communicationinfo	typeref:struct:communicationinfo::time	file:
setconfig	CNConfig.cpp	/^bool CNConfig::setconfig(cJSON* json, const char* configkey, const char* errormsg){$/;"	f	class:CNConfig
size	kfifo.h	/^	unsigned int size;	\/* the size of the allocated buffer *\/$/;"	m	struct:kfifo
skip	cJSON.c	/^static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}$/;"	f	file:
slot	sockets_buffer.c	/^	struct fd_buffer** slot;$/;"	m	struct:sockets_buffer	typeref:struct:sockets_buffer::fd_buffer	file:
slotcount	sockets_buffer.c	/^	int slotcount;$/;"	m	struct:sockets_buffer	file:
sockets_buffer	sockets_buffer.c	/^struct sockets_buffer{$/;"	s	file:
sockets_buffer_add	sockets_buffer.c	/^int sockets_buffer_add(struct sockets_buffer* sockets_buf, int fd,char *ip, unsigned char *buf, int len){$/;"	f
sockets_buffer_create	sockets_buffer.c	/^struct sockets_buffer* sockets_buffer_create(unsigned int slotcount){$/;"	f
sockets_buffer_del	sockets_buffer.c	/^int sockets_buffer_del(struct sockets_buffer* buf, int fd){ $/;"	f
sockets_buffer_destroy	sockets_buffer.c	/^int sockets_buffer_destroy(struct sockets_buffer* buf){$/;"	f
sockets_buffer_getfifo	sockets_buffer.c	/^struct kfifo* sockets_buffer_getfifo(struct sockets_buffer * sbuf, int fd){$/;"	f
sockets_buffer_print	sockets_buffer.c	/^int sockets_buffer_print(struct sockets_buffer* buf){$/;"	f
std	cnconfig.c	/^using namespace std;$/;"	v
string	cJSON.h	/^	char *string;				\/* The item's name string, if this item is the child of, or is in the list of subitems of an object. *\/$/;"	m	struct:cJSON
string	cnconfig.c	/^map<string, string>cnconfig_map;$/;"	v
suffix_object	cJSON.c	/^static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}$/;"	f	file:
swab16	cndef.h	26;"	d
swab32	cndef.h	34;"	d
tenms	encodeprotocol.c	/^	unsigned char tenms;$/;"	m	struct:time	file:
threadid_fmt	processappdata.c	/^	pthread_t threadid_fmt;$/;"	m	struct:processappdata	file:
time	encodeprotocol.c	/^struct time{$/;"	s	file:
tmp	fmtreportsockdata.c	/^unsigned char tmp[TMPSIZE];$/;"	v
tmplen	fmtreportsockdata.c	/^unsigned int tmplen = 0;$/;"	v
toolkit_cmdsep	toolkit.c	/^unsigned char * toolkit_cmdsep(unsigned char * cmd, unsigned int &len, unsigned char delim){ $/;"	f
toolkit_strsep	toolkit.c	/^char* toolkit_strsep(char* stringp, char delim){$/;"	f
type	cJSON.h	/^	int type;					\/* The type of the item, as above. *\/$/;"	m	struct:cJSON
unlikely	cndef.h	13;"	d
unlikely	cndef.h	16;"	d
urgentposition	encodeprotocol.c	/^	unsigned char urgentposition;$/;"	m	struct:positioninfo	file:
valuedouble	cJSON.h	/^	double valuedouble;			\/* The item's number, if type==cJSON_Number *\/$/;"	m	struct:cJSON
valueint	cJSON.h	/^	int valueint;				\/* The item's number, if type==cJSON_Number *\/$/;"	m	struct:cJSON
valuestring	cJSON.h	/^	char *valuestring;			\/* The item's string, if type==cJSON_String *\/$/;"	m	struct:cJSON
~CNConfig	CNConfig.h	/^	~CNConfig(){};$/;"	f	class:CNConfig
